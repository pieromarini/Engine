#version 460

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform SceneData {
	mat4 view;
	mat4 proj;
	mat4 viewproj;
	vec4 ambientColor;
	vec4 sunlightDirection;
	vec4 sunlightColor;
} sceneData;

layout (rgba8, set = 1, binding = 0) uniform image2D albedo;
layout (rgba16, set = 1, binding = 1) uniform image2D irradiance;
layout (r32f, set = 1, binding = 2) uniform image2D depthImage;

layout(push_constant) uniform constants {
	vec4 viewPosition;
	vec4 data2;
	vec4 data3;
	vec4 data4;
} PushConstants;

struct Ray {
	vec3 origin;
	vec3 direction;
};

struct VoxelGrid {
	vec3 minBound;
	uint numVoxelsX;

	vec3 maxBound;
	uint numVoxelsY;

	vec3 gridSize;
	uint numVoxelsZ;
};

struct RayHitInternal {
	vec3 pos;
	vec3 sideDist;
	vec3 deltaDist;
	ivec3 rayStep;
	uint material;
	bvec3 mask;
};

struct RayHit {
	uint material;
	vec3 pos;
	vec3 normal;
	vec3 dir;
};

struct Material {
	vec4 diffuse;
	float metallic;
};

layout(set = 1, binding = 3) readonly buffer Grid {
	VoxelGrid grid;
};

layout(set = 1, binding = 4) readonly buffer Voxels {
	uint voxels[];
};

layout (set = 1, binding = 5) uniform sampler2D blueNoise;

// Constants
// TODO(piero): make configurable
const int MAX_RAY_STEPS = 512;
const int MAX_REFLECTIONS = 2;
const int AO_SAMPLES = 0;

Material getMaterial(uint materialID) {
	Material material;
	material.metallic = 0.0f;

	switch(materialID) {
		case 1:
			material.diffuse = vec4(0.2f, 0.7f, 0.3f, 1.0f);
			material.metallic = 0.0f;
			break;
		case 2:
			material.diffuse = vec4(0.6f, 0.4f, 0.2f, 1.0f);
			material.metallic = 0.0f;
			break;
		case 3:
			material.diffuse = vec4(0.5f, 0.5f, 0.5f, 1.0f);
			material.metallic = 0.0f;
			break;

		// sky color (light blue)
		default:
			material.diffuse = vec4(0.5f, 0.7f, 1.0f, 1.0f);
			break;
	}

	return material;
}

vec3 fragmentNoiseSeq(uint num) {
	uint frameNum = uint(PushConstants.data2.x);
	uint offset = num * 32 + frameNum % 32;

	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 imageResolution = vec2(512);
	vec2 texCoords = (vec2(texelCoord) + 0.5) / vec2(imageResolution);
	vec2 clipCoords = texCoords * 2.0 - 1.0; // Convert to [-1, 1] range

	const float g = 1.22074408460575947536;
	const vec3 a = vec3(1.0 / g, 1.0 / (g * g), 1.0 / (g * g * g));
	vec3 noise = texture(blueNoise, clipCoords).rgb;
	return mod(noise + offset * a, 1.0);
}

// Generates a random direction within the unit sphere
vec3 randomDir(uint num) {
	return normalize(fragmentNoiseSeq(num) * 2.0 - vec3(1.0));
}

// NOTE(piero): Sizes MUST be a power of two (because of the & operator to speed up modulo.)
uint getLinearIndex(ivec3 pos, ivec3 gridSize) {
	return (pos.x & (gridSize.x - 1)) +
				 (pos.z & (gridSize.z - 1)) * gridSize.z +
				 (pos.y & (gridSize.y - 1)) * (gridSize.x * gridSize.z);
}

uint getVoxel(ivec3 pos, ivec3 gridSize) {
	uint index = getLinearIndex(pos, gridSize);
	return voxels[index];
}

// Function to convert clip space coordinates to ray direction
Ray rayFromCamera(vec2 clipCoords, vec3 cameraPosition) {
	// Convert to NDC space
	vec4 ndcPos = vec4(clipCoords.x, clipCoords.y, 1.0, 1.0);

	// Unproject using inverse projection and view matrices
	vec4 viewPos = inverse(sceneData.proj) * ndcPos;
	viewPos /= viewPos.w;

	vec4 worldPos = inverse(sceneData.view) * viewPos;

	Ray ray;

	ray.origin = cameraPosition;
	// Ray direction in world space
	ray.direction = normalize(worldPos.xyz - cameraPosition);

	return ray;
}

vec3 clipRayToAABB(Ray ray, vec3 bbMin, vec3 bbMax) {
	vec3 invDir = 1.0 / ray.direction;
	vec3 t1 = (bbMin - ray.origin) * invDir;
	vec3 t2 = (bbMax - ray.origin) * invDir;
	vec3 temp = t1;
	t1 = min(temp, t2);
	t2 = max(temp, t2);

	float tmin = max(t1.x, max(t1.y, t1.z));
	float tmax = min(t2.x, min(t2.y, t2.z));

	return tmin >= 0 && tmax >= tmin ? ray.origin + ray.direction * (tmin + 0.001) : ray.origin;
}

bool checkBounds(ivec3 pos, vec3 gridSize) {
	return pos.x >= 0 && pos.x < gridSize.x &&
		pos.y >= 0 && pos.y < gridSize.y && 
		pos.z >= 0 && pos.z < gridSize.z;
}

RayHitInternal traceRayInternal(Ray ray, VoxelGrid grid, uint maxSteps) {
	RayHitInternal result;

	// Ray starting position
	result.pos = clipRayToAABB(ray, grid.minBound, grid.maxBound);

	// First voxel to sample
	ivec3 mapPos = ivec3(floor(result.pos));

	// Portion of ray needed for ray to traverse a voxel in each direction
	result.deltaDist = abs(1.0f / ray.direction);

	// Integer position steps along ray
	result.rayStep = ivec3(sign(ray.direction));

	// Distance ray can travel in each direction before crossing a boundary
	result.sideDist = (sign(ray.direction) * (vec3(mapPos) - result.pos) + (sign(ray.direction) * 0.5) + 0.5) * result.deltaDist;

	for (uint i = 0; i < maxSteps; i++) {
		if (!checkBounds(mapPos, grid.maxBound)) {
			break;
		}

		// If we hit a voxel, break
		result.material = getVoxel(mapPos, ivec3(grid.gridSize));
		if (result.material != 0) {
			break;
		}

		// Determine which direction has minimum travel distance before hitting a boundary
		result.mask = lessThanEqual(result.sideDist.xyz, min(result.sideDist.yzx, result.sideDist.zxy));

		// Advance the distance needed for that axis
		result.sideDist += vec3(result.mask) * result.deltaDist;

		// Advance the integer map positon
		mapPos += ivec3(vec3(result.mask)) * result.rayStep;
	}

	return result;
}

RayHit traceRay(Ray ray, VoxelGrid grid, uint maxSteps) {
	RayHitInternal hitInternal = traceRayInternal(ray, grid, maxSteps);

	RayHit result;
	result.material = hitInternal.material;
	result.dir = ray.direction;

	if (result.material != 0) {
		// Calculate normal direction from final mask
		result.normal = normalize(vec3(hitInternal.mask) * -vec3(hitInternal.rayStep));

		// Calculate the ending position from distance traveled
		float d = length(vec3(hitInternal.mask) * (hitInternal.sideDist - hitInternal.deltaDist));
		result.pos = hitInternal.pos + d * ray.direction;
	}

	return result;
}

bool traceRayHit(Ray ray, VoxelGrid grid, uint maxSteps) {
	RayHitInternal hitInternal = traceRayInternal(ray, grid, maxSteps);
	return hitInternal.material != 0;
}

vec3 skyColor(RayHit hit) {
	Material skyMaterial = getMaterial(0);
	// Quick sky gradient
	return mix(skyMaterial.diffuse.xyz, skyMaterial.diffuse.xyz * 0.7, 0.5 * hit.dir.y + 0.5);
}

// Generates a random direction within the unit sphere
vec3 calcAmbient(RayHit hit, uint depth) {
    float ambient = 0.0;

    if (AO_SAMPLES == 0) {
        ambient = 0.3;
    } else {
			float sampleFrac = 1.0f / AO_SAMPLES;
			for (uint i = 0; i < AO_SAMPLES; i++) {
				// Generate a random direction around the normal
				vec3 dir = hit.normal + randomDir(i + depth * AO_SAMPLES);

				// Trace ray
				Ray ray;
				ray.origin = hit.pos + dir * 0.01;
				ray.direction = dir;
				bool hit = traceRayHit(ray, grid, 64);

				// Add ambient color if hit
				if (hit) {
					ambient += sampleFrac;
				}
			}
    }

    return ambient * 1.0f * skyColor(hit);
}

vec3 color(RayHit ray, Material material, vec3 ambient, vec3 reflection, bool shadowed) {
	vec3 diffuse = vec3(0.0);
	if (!shadowed) {
		float diff = max(dot(ray.normal, normalize(sceneData.sunlightDirection.xyz)), 0.0);
		diffuse = diff * sceneData.sunlightColor.rgb * 0.2f;
	}

	vec3 specular = reflection * material.metallic;

	return (diffuse + specular + ambient) * material.diffuse.xyz;
}

bool isShadowed(RayHit hit, VoxelGrid grid, uint maxSteps) {
	Ray r;
	r.origin = hit.pos + hit.normal * 0.01;
	r.direction = normalize(sceneData.sunlightDirection.xyz);
	return traceRayHit(r, grid, maxSteps);
}

vec3 colorHit(RayHit hit, vec3 reflection, uint depth) {
	if (hit.material != 0) {
		Material material = getMaterial(hit.material);

		vec3 ambient = calcAmbient(hit, depth);
		bool shadowed = isShadowed(hit, grid, 512);

		return color(hit, material, ambient, reflection, shadowed) * 1.0f / float(depth + 1);
	} else {
		return skyColor(hit);
	}
}

vec3 colorMainRay(RayHit hit, VoxelGrid grid) {
	// Get hit material
	Material material = getMaterial(hit.material);

	vec3 reflection = vec3(0.0);
	if (material.metallic > 0.0) {
		// Stack of reflection bounces
		RayHit bounces[MAX_REFLECTIONS];

		// Continue taking reflection bounces until we reach our maximum
		RayHit lastHit = hit;
		int lastIdx = -1;
		for (int i = 0; i < MAX_REFLECTIONS; i++) {
			vec3 reflectDir = reflect(lastHit.dir, lastHit.normal);

			Ray r;
			r.origin = lastHit.pos + lastHit.normal * 0.01;
			r.direction = reflectDir;

			RayHit reflectHit = traceRay(r, grid, 512);

			// Store reflection bounce in stack
			bounces[i] = reflectHit;
			lastHit = reflectHit;

			// Terminate early if material isn't metallic or we hit sky
			if (lastHit.material == 0 || getMaterial(lastHit.material).metallic <= 0.0) {
				lastIdx = i;
				break;
			}
		}

		// Sum backwards up the stack
		for (int i = lastIdx; i >= 0; i--) {
			reflection += colorHit(bounces[i], reflection, i);
		}
	}

	return colorHit(hit, reflection, 0);
}

void main() {
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 imageResolution = imageSize(albedo);

	if (any(greaterThanEqual(texelCoord, imageResolution))) {
		return;
	}

	vec2 texCoords = (vec2(texelCoord) + 0.5) / vec2(imageResolution);
	vec2 clipCoords = texCoords * 2.0 - 1.0; // Convert to [-1, 1] range

	vec3 cameraPosition = PushConstants.viewPosition.xyz;

	// Calculate ray direction in world space
	Ray ray = rayFromCamera(clipCoords, cameraPosition);

	// Cast the ray into the voxel grid
	RayHit result = traceRay(ray, grid, MAX_RAY_STEPS);

	vec3 color;

	if (result.material != 0) {
		color = colorMainRay(result, grid);
		float depthValue = length(result.pos - cameraPosition);
		imageStore(depthImage, texelCoord, vec4(depthValue, 0.0f, 0.0f, 0.0f));
	} else {
		color = skyColor(result);
		imageStore(albedo, texelCoord, vec4(0.0f));
	}

	vec4 finalColor = vec4(color, 1.0f);

	// Store final color
	imageStore(albedo, texelCoord, finalColor);

	// imageStore(irradiance, texelCoord, vec4(finalColor.rgb, 1.0));
}
